<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>WebGPU Cube</title>
  <style>canvas { width: 100vw; height: 100vh; display: block; }</style>
</head>
<body>
<canvas id="gpu-canvas"></canvas>
<script type="module">
import { mat4 } from 'https://cdn.skypack.dev/gl-matrix';

async function init() {
  const canvas = document.getElementById("gpu-canvas");
  const adapter = await navigator.gpu.requestAdapter();
  const device = await adapter.requestDevice();
  const context = canvas.getContext("webgpu");

  const format = navigator.gpu.getPreferredCanvasFormat();
  context.configure({ device, format, alphaMode: "opaque" });

  // 顶点数据 (位置 + 颜色)
  const vertexData = new Float32Array([
    // position           color
    -1,-1,-1,   1,0,0,
     1,-1,-1,   0,1,0,
     1, 1,-1,   0,0,1,
    -1, 1,-1,   1,1,0,
    -1,-1, 1,   1,0,1,
     1,-1, 1,   0,1,1,
     1, 1, 1,   1,1,1,
    -1, 1, 1,   0,0,0
  ]);

  const indexData = new Uint16Array([
    0,1,2,  2,3,0,
    4,5,6,  6,7,4,
    0,4,7,  7,3,0,
    1,5,6,  6,2,1,
    3,2,6,  6,7,3,
    0,1,5,  5,4,0
  ]);

  const vertexBuffer = device.createBuffer({
    size: vertexData.byteLength,
    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
  });
  device.queue.writeBuffer(vertexBuffer, 0, vertexData);

  const indexBuffer = device.createBuffer({
    size: indexData.byteLength,
    usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST
  });
  device.queue.writeBuffer(indexBuffer, 0, indexData);

  // uniform buffer for model-view-projection matrix
  const uniformBuffer = device.createBuffer({
    size: 64,
    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
  });

  const uniformBindGroupLayout = device.createBindGroupLayout({
    entries: [{ binding: 0, visibility: GPUShaderStage.VERTEX, buffer: {} }]
  });

  const uniformBindGroup = device.createBindGroup({
    layout: uniformBindGroupLayout,
    entries: [{ binding: 0, resource: { buffer: uniformBuffer } }]
  });

  const shaderModule = device.createShaderModule({
    code: `
struct Uniforms {
  mvpMatrix : mat4x4<f32>
};
@binding(0) @group(0) var<uniform> uniforms : Uniforms;

struct VertexInput {
  @location(0) position : vec3<f32>,
  @location(1) color : vec3<f32>
};

struct VertexOutput {
  @builtin(position) position : vec4<f32>,
  @location(0) color : vec3<f32>
};

@vertex
fn vs_main(input : VertexInput) -> VertexOutput {
  var output : VertexOutput;
  output.position = uniforms.mvpMatrix * vec4f(input.position, 1.0);
  output.color = input.color;
  return output;
}

@fragment
fn fs_main(input : VertexOutput) -> @location(0) vec4f {
  return vec4f(input.color, 1.0);
}`
  });

  const pipeline = device.createRenderPipeline({
    layout: device.createPipelineLayout({ bindGroupLayouts: [uniformBindGroupLayout] }),
    vertex: {
      module: shaderModule,
      entryPoint: "vs_main",
      buffers: [{
        arrayStride: 6 * 4,
        attributes: [
          { shaderLocation: 0, offset: 0, format: 'float32x3' }, // position
          { shaderLocation: 1, offset: 3 * 4, format: 'float32x3' }  // color
        ]
      }]
    },
    fragment: {
      module: shaderModule,
      entryPoint: "fs_main",
      targets: [{ format }]
    },
    primitive: { topology: "triangle-list", cullMode: "back" },
    depthStencil: {
      format: "depth24plus",
      depthWriteEnabled: true,
      depthCompare: "less"
    }
  });

  const depthTexture = device.createTexture({
    size: [canvas.width, canvas.height],
    format: "depth24plus",
    usage: GPUTextureUsage.RENDER_ATTACHMENT
  });

  function frame(time) {
    const aspect = canvas.width / canvas.height;
    const projection = mat4.create();
    const view = mat4.create();
    const model = mat4.create();
    const mvp = mat4.create();

    mat4.perspective(projection, Math.PI / 4, aspect, 0.1, 100);
    mat4.lookAt(view, [3,3,6], [0,0,0], [0,1,0]);
    mat4.rotateY(model, model, time * 0.001);
    mat4.rotateX(model, model, time * 0.001 * 0.5);
    mat4.multiply(mvp, projection, view);
    mat4.multiply(mvp, mvp, model);

    device.queue.writeBuffer(uniformBuffer, 0, mvp.buffer);

    const encoder = device.createCommandEncoder();
    const pass = encoder.beginRenderPass({
      colorAttachments: [{
        view: context.getCurrentTexture().createView(),
        loadOp: "clear",
        clearValue: { r: 0.1, g: 0.1, b: 0.1, a: 1 },
        storeOp: "store"
      }],
      depthStencilAttachment: {
        view: depthTexture.createView(),
        depthClearValue: 1.0,
        depthLoadOp: "clear",
        depthStoreOp: "store"
      }
    });

    pass.setPipeline(pipeline);
    pass.setVertexBuffer(0, vertexBuffer);
    pass.setIndexBuffer(indexBuffer, "uint16");
    pass.setBindGroup(0, uniformBindGroup);
    pass.drawIndexed(36);
    pass.end();

    device.queue.submit([encoder.finish()]);
    requestAnimationFrame(frame);
  }

  frame();
}

init();
</script>
</body>
</html>
