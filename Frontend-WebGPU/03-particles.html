<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>WebGPU Particle System</title>
  <style>body, html {margin:0;overflow:hidden;height:100%;}</style>
</head>
<body>
<canvas id="c"></canvas>
<script type="module">
  // init
  const canvas = document.getElementById('c');
  const adapter = await navigator.gpu.requestAdapter();
  const device = await adapter.requestDevice();
  const context = canvas.getContext('webgpu');
  const format = navigator.gpu.getPreferredCanvasFormat();
  context.configure({ device, format });

  const COUNT = 100_000;
  const WG = 64;
  const STRIDE = 4 * 4; // vec2 pos, vec2 vel

  // particle buffer
  const buf = device.createBuffer({
    size: COUNT * STRIDE,
    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
    mappedAtCreation: true
  });
  {
    const a = new Float32Array(buf.getMappedRange());
    for (let i = 0; i < COUNT; i++) {
      const o = i * 4;
      a[o    ] = Math.random() * 2 - 1;
      a[o + 1] = Math.random() * 2 - 1;
      a[o + 2] = Math.random() * 0.01 - 0.005;
      a[o + 3] = Math.random() * 0.01 - 0.005;
    }
    buf.unmap();
  }

  // compute shader (WGSL)
  const compCode = `
struct Particle {
  pos: vec2<f32>,
  vel: vec2<f32>,
}

@group(0) @binding(0)
var<storage, read_write> particles: array<Particle>;

@compute @workgroup_size(${WG})
fn main(@builtin(global_invocation_id) id: vec3<u32>) {
  let i = id.x;
  if (i >= ${COUNT}u) { return; }
  var p = particles[i];
  p.pos += p.vel;
  if (p.pos.x > 1.0) { p.pos.x = -1.0; }
  if (p.pos.x < -1.0) { p.pos.x =  1.0; }
  if (p.pos.y > 1.0) { p.pos.y = -1.0; }
  if (p.pos.y < -1.0) { p.pos.y =  1.0; }
  particles[i] = p;
}
`;
  const compMod = device.createShaderModule({ code: compCode });
  const compPipe = device.createComputePipeline({
    layout: 'auto',
    compute: { module: compMod, entryPoint: 'main' }
  });
  const compBG = device.createBindGroup({
    layout: compPipe.getBindGroupLayout(0),
    entries: [{ binding: 0, resource: { buffer: buf } }]
  });

  // render shader (WGSL)
  const rendCode = `
struct Particle {
  pos: vec2<f32>,
  vel: vec2<f32>,
}

struct VSOut {
  @builtin(position) pos: vec4<f32>,
  @location(0) color: vec3<f32>,
}

@group(0) @binding(0)
var<storage, read> particles: array<Particle>;

@vertex
fn vs(@builtin(instance_index) i: u32) -> VSOut {
  let p = particles[i].pos;
  var out: VSOut;
  out.pos = vec4(p, 0.0, 1.0);
  out.color = vec3(0.8, 0.2, 0.5);
  return out;
}

@fragment
fn fs(in: VSOut) -> @location(0) vec4<f32> {
  return vec4(in.color, 1.0);
}
`;
  const rendMod = device.createShaderModule({ code: rendCode });
  const rendPipe = device.createRenderPipeline({
    layout: 'auto',
    vertex:   { module: rendMod, entryPoint: 'vs', buffers: [] },
    fragment: { module: rendMod, entryPoint: 'fs', targets: [{ format }] },
    primitive: { topology: 'point-list' }
  });
  const rendBG = device.createBindGroup({
    layout: rendPipe.getBindGroupLayout(0),
    entries: [{ binding: 0, resource: { buffer: buf } }]
  });

  // resize
  function resize() {
    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;
  }
  window.addEventListener('resize', resize);
  resize();

  // frame loop
  function frame() {
    const cmd = device.createCommandEncoder();

    // compute pass
    const cp = cmd.beginComputePass();
    cp.setPipeline(compPipe);
    cp.setBindGroup(0, compBG);
    cp.dispatchWorkgroups(Math.ceil(COUNT / WG));
    cp.end();

    // render pass
    const view = context.getCurrentTexture().createView();
    const rp = cmd.beginRenderPass({
      colorAttachments: [{
        view,
        loadOp: 'clear',
        clearValue: { r: 0, g: 0, b: 0, a: 1 },
        storeOp: 'store'
      }]
    });
    rp.setPipeline(rendPipe);
    rp.setBindGroup(0, rendBG);
    rp.draw(1, COUNT);
    rp.end();

    device.queue.submit([cmd.finish()]);
    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);
</script>
</body>
</html>
